// generate all numbers for stops
// generate all rows
// intersect

use std::iter;

use crate::schema::Cell::{self, Crossed as X, Empty as N, Full as O};

/// This function can be used to compute the intersection of two rows in a two-dimensional grid
/// of `nonogram::schema::Cell` values, where the intersection is defined as the set of elements
/// that appear in both rows.
///
/// Cells that are different in the two rows are set to `nonogram::Cell::Empty`.
/// It mutates the `row1` slice.
///
/// # Examples
///
/// ```ignore
/// use nonogram::schema::Cell::{Crossed as X, Full as O, Empty as N};
///
/// let row1 = &[X, O, O, X, N];
/// let row2 = &[O, X, O, X, N];
/// let expc = &[N, N, O, X, N];
/// let mut buf = Vec::from(row1);
/// intersect(&mut buf, row2.iter().copied());
/// assert_eq!(buf, expc);
/// ```
pub(crate) fn intersect(row1: &mut [Cell], row2: impl Iterator<Item = Cell>) {
    for (c, c2) in row1.iter_mut().zip(row2) {
        if *c != c2 {
            *c = N;
        }
    }
}

/// Generates all possible solutions to the provided row information.
///
/// The solutions are generated by taking all possible empty cells between the provided
/// labels, considering a row length of `length`.
///
/// Solutions are returned in a vector of vectors, each one of the vectors representing
/// the empty cells between labels.
///
/// For example, given the labels `[1, 2]` and a length of `5`, the results should be:
/// - `[0, 1, 1]`, representing the row `[O.XX.]`
/// - `[0, 2, 0]`, representing the row `[O..XX]`
/// - `[1, 1, 0]`, representing the row `[.O.XX]`
pub(crate) fn numbers(labels: &[usize], length: usize) -> Vec<Vec<usize>> {
    let len = labels.len() + 1;
    let sum = length - labels.iter().sum::<usize>();

    let mut buf = Vec::with_capacity(100);
    let mut cur = vec![0; len];
    _rec(&mut cur, 0, 0, sum, &mut buf);

    buf
}

fn _rec(cur: &mut [usize], index: usize, cur_sum: usize, sum: usize, buf: &mut Vec<Vec<usize>>) {
    let last = cur.len() - 1;
    if index > last {
        if cur_sum == sum {
            buf.push(cur.to_vec());
        }
        return;
    }

    let inf = if index == 0 || index == last { 0 } else { 1 };
    let sup = sum; // TODO improve

    for i in inf..=sup {
        cur[index] = i;
        _rec(cur, index + 1, cur_sum + i, sum, buf);
    }
}

/// Generates an iterator of `nonogram::schema::Cell`.
/// The cells returned by the iterator are generated by zipping
/// `crossed_nums` and `full_nums`.
///
/// This function panics if `crossed_nums.len() != full_nums.len() + 1`.
///
/// Any number can be zero.
///
/// Crossed values are taken first, and the last is used for generating
/// the last set of values.
///
/// # Examples
///
/// ```ignore
/// use nonogram::schema::Cell::{Crossed as X, Full as O};
/// let crossed_nums = &[1, 2, 3];
/// let full_nums = &[3, 2];
/// let row = numbers_to_row(crossed_nums, full_nums);
/// assert_eq!(row, &[X, O, O, O, X, X, O, O, X, X, X]);
///
/// use nonogram::schema::Cell::{Crossed as X, Full as O};
/// let crossed_nums = &[0, 1];
/// let full_nums = &[2];
/// let row = numbers_to_row(crossed_nums, full_nums);
/// assert_eq!(row, &[O, X, X, O]);
/// ```
pub(crate) fn numbers_to_row<'a>(
    crossed_nums: &'a [usize],
    full_nums: &'a [usize],
) -> Box<dyn Iterator<Item = Cell> + 'a> {
    if crossed_nums.len() != full_nums.len() + 1 {
        panic!("Invalid");
    }

    let last = *crossed_nums.last().unwrap();

    Box::new(
        crossed_nums
            .iter()
            .zip(full_nums)
            .flat_map(|(&empties, &filled)| {
                iter::repeat(X)
                    .take(empties)
                    .chain(iter::repeat(O).take(filled))
            })
            .chain(iter::repeat(X).take(last)),
    )
}

fn get_row(labels: &[usize], starting_row: Vec<Cell>) -> Vec<Cell> {
    let length = starting_row.len();
    let mut iter = numbers(labels, length).into_iter();

    let mut cur = if starting_row.iter().all(|&c| c == N) {
        numbers_to_row(&iter.next().unwrap(), labels).collect()
    } else {
        starting_row
    };

    for r in iter {
        let r = numbers_to_row(&r, labels);
        intersect(&mut cur, r.into_iter());
    }

    cur
}
