// generate all numbers for stops
// generate all rows
// intersect

use std::{collections::VecDeque, iter};

use itertools::Itertools;

use crate::schema::{
    Cell::{self, Crossed as X, Empty as N, Full as O},
    NonogramSchema,
};

/// This function can be used to compute the intersection of two rows in a two-dimensional grid
/// of `nonogram::schema::Cell` values, where the intersection is defined as the set of elements
/// that appear in both rows.
///
/// Cells that are different in the two rows are set to `nonogram::Cell::Empty`.
/// It mutates the `row1` slice.
///
/// # Examples
///
/// ```ignore
/// use nonogram::schema::Cell::{Crossed as X, Full as O, Empty as N};
///
/// let row1 = &[X, O, O, X, N];
/// let row2 = &[O, X, O, X, N];
/// let expc = &[N, N, O, X, N];
/// let mut buf = Vec::from(row1);
/// intersect(&mut buf, row2.iter().copied());
/// assert_eq!(buf, expc);
/// ```
pub(crate) fn intersect(row1: &mut [Cell], row2: impl Iterator<Item = Cell>) {
    for (c, c2) in row1.iter_mut().zip(row2) {
        if *c != c2 {
            *c = N;
        }
    }
}

/// Generates all possible solutions to the provided row information.
///
/// The solutions are generated by taking all possible empty cells between the provided
/// labels, considering a row length of `length`.
///
/// Solutions are returned in a vector of vectors, each one of the vectors representing
/// the empty cells between labels.
///
/// For example, given the labels `[1, 2]` and a length of `5`, the results should be:
/// - `[0, 1, 1]`, representing the row `[O.XX.]`
/// - `[0, 2, 0]`, representing the row `[O..XX]`
/// - `[1, 1, 0]`, representing the row `[.O.XX]`
pub(crate) fn numbers(labels: &[usize], length: usize) -> Vec<Vec<usize>> {
    let len = labels.len() + 1;
    let sum = length - labels.iter().sum::<usize>();

    let mut buf = Vec::with_capacity(100);
    let mut cur = vec![0; len];
    _rec(&mut cur, 0, 0, sum, &mut buf);

    buf
}

fn _rec(cur: &mut [usize], index: usize, cur_sum: usize, sum: usize, buf: &mut Vec<Vec<usize>>) {
    let last = cur.len() - 1;
    if index > last {
        if cur_sum == sum {
            buf.push(cur.to_vec());
        }
        return;
    }

    let inf = if index == 0 || index == last { 0 } else { 1 };
    let sup = sum; // TODO improve

    for i in inf..=sup {
        cur[index] = i;
        _rec(cur, index + 1, cur_sum + i, sum, buf);
    }
}

/// Generates an iterator of `nonogram::schema::Cell`.
/// The cells returned by the iterator are generated by zipping
/// `crossed_nums` and `full_nums`.
///
/// This function panics if `crossed_nums.len() != full_nums.len() + 1`.
///
/// Any number can be zero.
///
/// Crossed values are taken first, and the last is used for generating
/// the last set of values.
///
/// # Examples
///
/// ```ignore
/// use nonogram::schema::Cell::{Crossed as X, Full as O};
/// let crossed_nums = &[1, 2, 3];
/// let full_nums = &[3, 2];
/// let row = numbers_to_row(crossed_nums, full_nums);
/// assert_eq!(row, &[X, O, O, O, X, X, O, O, X, X, X]);
///
/// use nonogram::schema::Cell::{Crossed as X, Full as O};
/// let crossed_nums = &[0, 1];
/// let full_nums = &[2];
/// let row = numbers_to_row(crossed_nums, full_nums);
/// assert_eq!(row, &[O, X, X, O]);
/// ```
pub(crate) fn numbers_to_vec<'a>(
    crossed_nums: &'a [usize],
    full_nums: &'a [usize],
) -> Box<dyn Iterator<Item = Cell> + 'a> {
    if crossed_nums.len() != full_nums.len() + 1 {
        panic!("Invalid");
    }

    let last = *crossed_nums.last().unwrap();

    Box::new(
        crossed_nums
            .iter()
            .zip(full_nums)
            .flat_map(|(&empties, &filled)| {
                iter::repeat(X)
                    .take(empties)
                    .chain(iter::repeat(O).take(filled))
            })
            .chain(iter::repeat(X).take(last)),
    )
}

pub fn solve_vec(labels: &[usize], starting_vec: &[Cell]) -> Vec<Cell> {
    let length = starting_vec.len();
    let mut iter = numbers(labels, length).into_iter();

    let mut cur = numbers_to_vec(&iter.next().unwrap(), labels).collect_vec();

    for r in iter {
        let r = numbers_to_vec(&r, labels);
        intersect(&mut cur, r.into_iter());
    }

    let mut res = starting_vec.to_vec();

    for (x, y) in res.iter_mut().zip(cur) {
        if *x == N {
            *x = y;
        }
    }

    res
}

fn solve_row(
    schema: &mut NonogramSchema,
    i: usize,
    modified: &mut VecDeque<(char, usize)>,
    rows_solved: &mut [bool],
) {
    if rows_solved[i] {
        return;
    }
    let row = schema.row_at(i);
    let labels = schema.row_label_at(i);
    let solved = solve_vec(labels, &row);
    for (j, (a, b)) in row.iter().zip(solved.iter()).enumerate() {
        if *a != *b {
            modified.push_back(('c', j));
        }
    }

    schema.set_row_at(i, &solved);
    if schema.solved_row(i) {
        rows_solved[i] = true;
    }
}

fn solve_col(
    schema: &mut NonogramSchema,
    j: usize,
    modified: &mut VecDeque<(char, usize)>,
    cols_solved: &mut [bool],
) {
    if cols_solved[j] {
        return;
    }
    let col = schema.col_at(j);
    let labels = schema.col_label_at(j);
    let solved = solve_vec(labels, &col);
    for (i, (a, b)) in col.iter().zip(solved.iter()).enumerate() {
        if *a != *b {
            modified.push_back(('r', i));
        }
    }

    schema.set_col_at(j, &solved);
    if schema.solved_col(j) {
        cols_solved[j] = true;
    }
}

pub fn solve(schema: &mut NonogramSchema) {
    let mut rows_solved = vec![false; schema.rows()];
    let mut cols_solved = vec![false; schema.cols()];

    let mut modified = VecDeque::new();

    for i in 0..schema.rows() {
        modified.push_back(('r', i));
    }

    for j in 0..schema.cols() {
        modified.push_back(('c', j));
    }

    while !modified.is_empty() {
        match modified.pop_front().unwrap() {
            ('r', i) => solve_row(schema, i, &mut modified, &mut rows_solved),
            ('c', j) => solve_col(schema, j, &mut modified, &mut cols_solved),
            _ => unreachable!(),
        }
    }

    // if !rows_solved.iter().all(|v| *v) || !cols_solved.iter().all(|v| *v) {
    //     panic!("impossible");
    // }
}
